# Copyright 2025 Wonder Dynamics (an Autodesk Company)

# This source code is licensed under the GNU GPLv3
# found in the LICENSE file in the root directory of this source tree.

"""Module for all the Metadata validator classes."""

import bpy

from .character_metadata_definition import CharacterMetadata
from .validator import Validator

# The way Validator is inherited by child classes currently do change check signature
# This is something to refactor in the future, but it would take time. TODO:
# pylint: disable=arguments-renamed,arguments-differ


class ValidatorMetadata:
    """Class that does all the validation of the metadata by delegating the work to
    classes like ValidatorMetadataVerify, ValidatorMetadataVersion and
    ValidatorMetadataMetadata.
    """

    def __call__(self, metadata: dict, current_addon_version: str) -> dict:
        """Do the metadata validation.
        Args:
            metadata (dict): the metadata dictionary to inspect.
            current_addon_version (str): The addon version, for example 1.0.2
        Returns:
            dict: a dictionary holding the results of all the validations run where
                keys are the identifier of the validation and values are dictionaries
                with the following keys:
                    check (bool): whether or not the check passed.
                    message (str): the explanation of what was being checked.
        """
        report_dict = {}

        verify_object = ValidatorMetadataVerify(metadata)
        report_dict[verify_object.key] = verify_object()

        if report_dict[verify_object.key]['check']:
            version_object = ValidatorMetadataVersion(metadata, current_addon_version)
            report_dict[version_object.key] = version_object()

            metadata_object = ValidatorMetadataMetadata(metadata)
            report_dict[metadata_object.key] = metadata_object()

        return report_dict


class ValidatorMetadataVerify(Validator):
    """Validates that the metadata has the expected keys and valid values."""

    def __init__(self, metadata: dict) -> None:
        super().__init__()
        self.message = (
            'Metadata corrupted or altered! Metadata does not contain the required keys and formats. '
            'Please make sure to generate the metadata.json file with the latest version of the addon.'
        )
        self.key = 'verify_check'

        self.metadata = metadata

    def __call__(self) -> dict:
        check = self.check()
        return {'check': check, 'message': self.message}

    def check(self) -> bool:
        try:
            CharacterMetadata(**self.metadata)
        except (ValueError, TypeError):
            return False

        return True


class ValidatorMetadataVersion(Validator):
    """Validates that the metadata was generated by current add-on."""

    def __init__(self, metadata: dict, current_addon_version: str) -> None:
        super().__init__()
        self.message = (
            'Wrong metadata version! Please use the latest version of the addon'
            ' to generate the metadata.'
            )
        self.key = 'version_check'

        self.metadata = metadata
        self.current_addon_version = current_addon_version

    def get(self) -> str:
        version = self.metadata['version']
        return version

    def check(self, version: str) -> bool:
        if version == self.current_addon_version:
            return True
        else:
            return False


class ValidatorMetadataMetadata(Validator):
    """Validates that the information in metadata is consistent with objects in the scene."""

    def __init__(self, metadata: dict) -> None:
        super().__init__()
        self.message = (
            'Metadata information mismatch! The information in the metadata file does not match the '
            'information in the character scene! Please generate a new metadata file using the addon.'
            ' Do not alter any files after addon validation passes.'
        )
        self.key = 'metadata_check'

        self.metadata = metadata

    def __call__(self) -> dict:
        check = self.check()
        return {'check': check, 'message': self.message}

    def check(self) -> bool:
        # Main armature exists in the scene and is of type armature.
        if not self.metadata['body']['armature_name']:
            return False
        main_pose_armature = bpy.data.objects.get(self.metadata['body']['armature_name'])
        if not main_pose_armature or main_pose_armature.type != 'ARMATURE':
            return False
        # Listed bones exist in the scene.
        for bone_name in self.metadata['body']['bone_names'].values():
            if bone_name and not main_pose_armature.pose.bones.get(bone_name):
                return False
        # If main face main face exists in the scene and is of type mesh
        if self.metadata['face']['mesh_name']:
            main_face_mesh = bpy.data.objects.get(self.metadata['face']['mesh_name'])
            if not main_face_mesh or main_face_mesh.type != 'MESH':
                return False
            # If main face main face exists check if blendshapes exist
            for blendshape_name in self.metadata['face']['blendshape_names'].values():
                if blendshape_name and not main_face_mesh.data.shape_keys.key_blocks.get(blendshape_name):
                    return False
        # If eye rig check if bones exist
        if self.metadata['eyes_rig']:
            eyes_rig = self.metadata['eyes_rig']
            for eye in eyes_rig:
                if not eye['bone_name'] or not main_pose_armature.pose.bones.get(eye['bone_name']):
                    return False

        return True
